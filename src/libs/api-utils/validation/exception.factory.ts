import { Constraints, ValidationError } from '@libs/errors';
import { type ValidationError as ClassValidationError } from 'class-validator';

type ConstraintEntries = Array<[string, Constraints]>;

/**
 * Factory function used by Nest's global [ValidationPipe](https://docs.nestjs.com/techniques/validation) to transform
 * [class-validator](https://github.com/typestack/class-validator#class-validator) ValidationErrors
 * into domain [ValidationErrors](https://avantio.atlassian.net/wiki/spaces/CORE/pages/2987687937/Error+types)
 * @param errors Errors generated by class-validator when validating query and request objects.
 * @returns a single Validation Error containing all failed constraints
 */
export function exceptionFactory(
  errors: ClassValidationError[],
): ValidationError {
  const detailEntries: ConstraintEntries = [];

  for (const error of errors) {
    const entries = buildErrorDetailEntries(error);
    detailEntries.push(...entries);
  }

  const details = Object.fromEntries(detailEntries);

  return new ValidationError(details);
}

/**
 * Loop through class-validator error constraints to parse them into domain error constraints.
 * Each class-validator error can have multiple failed constraints.
 * Each class-validator error can also have nested error which are also parsed recursively.
 * @param error the error generated by class-validator
 * @param fieldPath the current fild path in object hierarchy
 * @returns Array containing touples field-constraint
 */
function buildErrorDetailEntries(
  error: ClassValidationError,
  fieldPath: string[] = [],
): ConstraintEntries {
  const details: ConstraintEntries = [];
  const key = [...fieldPath, error.property].join('.');

  if (error.constraints) {
    const failedConstraints = Object.entries(error.constraints);
    const fieldDetails = {};

    for (const [field, constraint] of failedConstraints) {
      Object.assign(fieldDetails, mapFailedConstraint(field, constraint));
    }
    details.push([key, fieldDetails]);
  }

  if (error.children) {
    for (const child of error.children) {
      const childDetails = buildErrorDetailEntries(child, [key]);
      details.push(...childDetails);
    }
  }

  return details;
}

/**
 * Function for mapping class-validator error types into Constraints
 * @param key class-validation error type
 * @param message optional message passed to validation function
 * @returns Constraint object or the message as text
 */
function mapFailedConstraint(key: string, message = ''): Constraints {
  switch (key) {
    case 'arrayNotEmpty':
    case 'isNotEmpty':
      return { required: true };
    case 'isNumberString':
      return { type: 'number', text: message ? message : 'numeric string' };
    case 'isNumber':
      return { type: 'number' };
    case 'isString':
      return { type: 'string' };
    case 'isDate':
    case 'isDateString':
      return { type: 'date' };
    case 'isPast':
      return { past: true };
    case 'isBoolean':
      return { type: 'boolean' };
    case 'isArray':
      return { type: 'array' };
    case 'isEmail':
      return { type: 'email' };
    case 'arrayMinSize':
    case 'minLength':
    case 'min':
      return { min: Number(message.replace(/\D*/g, '')) };
    case 'arrayMaxSize':
    case 'maxLength':
    case 'max':
      return { max: Number(message.replace(/\D*/g, '')) };
    case 'isEnum':
    case 'isIn':
      return { in: message.split(',').map((s) => s.trim()) };
    case 'isExclusive':
      return { excluded: message };
    case 'nestedValidation':
      return { type: 'object' };
    case 'isRange':
      return { range: true };
    case 'isISO31661Alpha2':
      return { format: 'ISO 3166-2' };
    case 'isAfter':
      return { after: message };
    case 'isValidPhoneNumber':
      return { text: 'Invalid phone number' };
    case 'noOverlappingRanges':
      return { overlap: false, text: 'Contains overlapping ranges' };
    case 'inRangeNumberString':
      return { text: `Number must be between ${message}` };
    default:
      return { text: message };
  }
}
